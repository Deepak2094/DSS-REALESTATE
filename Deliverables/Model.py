import copy
import pandas as pd

##########################################################
######                                              ######
######          PULL IN USER RESPONSES              ######
######                                              ######
##########################################################

# =============================================================================
# listings = pd.read_csv(r"C:\Users\User\Documents\GMU\SYST 542 - Decision Support Systems\Code\Updated Listings within 0.5 miles.csv",
#                        usecols = range(1,40))
#
# # Environmental Features dictionary - stand in for one generated by interface responses
# Environmental_Features = {	"Housebudget":"1VeryImportant",
# 							"HouseSize":"1Notimportantatall",
# 							"neighbourhoodfactors":"5Notimportantatall",
# 							"BusStop":"1Notimportantatall",
# 							"Metro":"1Notimportantatall",
# 							"CommunityCenter":"1Notimportantatall",
# 							"Library":"1Notimportantatall",
# 							"School_quality":"1Notimportantatall",
# 							"Restaurants":"5Notimportantatall",
# 							"Bars":"5Notimportantatall" }
# =============================================================================

# hard coding the user rating to a numeric value
rating_xwalk = {
    1: 0.00,
    2: 0.25,
    3: 0.50,
    4: 0.75,
    5: 1.00
}

# hard coding the interface values for each field to a
field_name_xwalk = {"Housebudget": "price",
                    "HouseSize": "size_in_sqft",
                    # "neighbourhoodfactors":"",
                    "BusStop": "BusDistance",
                    "Metro": "MetroDistance",
                    "CommunityCenter": "CCDistance",
                    "Library": "LIBDistance",
                    "School_quality": "RATING",
                    "Restaurants": "Mean_Rating_restaurants",
                    "Bars": "Mean_Rating_bars"}

# blank structure of responses, based on our attribute hierarchy model
structure = {
    "Housebudget": [1],
    "HouseSize": [1],
    "neighbourhoodfactors": [1,
                             {
                                 "BusStop": [1],
                                 "Metro": [1],
                                 "CommunityCenter": [1],
                                 "Library": [1],
                                 "School_quality": [1],
                                 "Restaurants": [1],
                                 "Bars": [1]
                             }
                             ]
}


##########################################################
######                                              ######
######          ASSIGN WEIGHTS TO MODEL             ######
######                                              ######
##########################################################

# read in a dictionary and replace all values with the integer value of the user response
def convert_responses(Environmental_Features):
    env_values = ['neighbourhoodfactors', 'HouseSize', 'Housebudget', 'BusStop', 'Metro', 'Restaurants', 'Bars',
                  'School_quality', 'CommunityCenter', 'Library']
    for key in Environmental_Features:
        if key in env_values:
            Environmental_Features[key] = [int(Environmental_Features[key][0])]
    return Environmental_Features


# Update the blank structure with the integer ratings the users chose for environmental features
def update_structure(structure, Environmental_Features):
    if type(structure) == type({}):
        # for each list element in the structure:
        for key in structure:
            # if the list has another layer, update current level and pass the next
            if type(structure[key]) == list and len(structure[key]) > 1:
                structure[key][0] = Environmental_Features[key][0]
                structure[key][1] = update_structure(structure[key][1], Environmental_Features)
            # otherwise just add the value of the first list index to the structure
            else:
                structure[key] = Environmental_Features[key]

    return structure


# read in a dictionary with lists as values and the user rating as the 1st element of said list
# distribute the weights of the response and return a new dictionary with the key and weight
def distribute_weights(tmp_dict):
    # crosswalk the ratings to a numeric value and sum them up for that level
    sum_values = sum([rating_xwalk[tmp_dict[x][0]] for x in tmp_dict])
    distributed_weights = {}

    # make the numeric values proportional for that level
    # i.e. level ratings of 1, 2, and 5 become 0.0, 0.2, 0.8
    for x in tmp_dict:
        if rating_xwalk[tmp_dict[x][0]] == 0:  # account for zero division
            weight = 0
        else:
            weight = rating_xwalk[tmp_dict[x][0]] / sum_values
        distributed_weights.update(
            {x: weight})  # assign a weight to the key based on the numeric value / sum of numeric values

    return distributed_weights


# read in a dictionary from the response structure
# replace the ratings in the dictionary with the distributed_weights function
def replace_with_weights(responses):
    weights = distribute_weights(responses)
    for item in weights:
        responses[item][0] = weights[item]

    return responses


# recursively assign weights per level of the structure
def assign_weights(tmp_dict):
    if type(tmp_dict) == type({}):
        tmp_dict = replace_with_weights(tmp_dict)
        for key in tmp_dict:
            if type(tmp_dict[key]) == list and len(tmp_dict[key]) > 1:
                assign_weights(tmp_dict[key][1])
            else:
                assign_weights(tmp_dict[key])

    return tmp_dict


# recursivley "trickle down" the weights throughout the structure
# i.e. home_features (.75) * home_details (.25) * baths (.50) == .09375 relative weight for baths
def trickle_down(val):
    # if the value passed to trickle down is a dictionary, continue down the structure
    # for each key in the dictionary
    if type(val) == type({}):
        for key in val:
            trickle_down(val[key])

    # if the value passed to trickle_down is a list with another level (i.e. len > 1)
    # then multiply the weight at the upper level down to the weights at the lower level
    if type(val) == type([]) and len(val) > 1:
        for key in val[1]:
            val[1][key][0] = val[0] * val[1][key][0]
        trickle_down(val[1])

    return val


# feed in the responses with ratings and return weights
def return_weights(structure, Environmental_Features):
    Environmental_Features = convert_responses(Environmental_Features)
    structure = update_structure(structure, Environmental_Features)
    weights = assign_weights(structure)
    weights = trickle_down(weights)
    return weights


##########################################################
######                                              ######
######       RANK LISTINGS BASED ON WEIGHTS         ######
######                                              ######
##########################################################

# Return a dictionary of model features and their weights
def return_unpacked_weights(weights):
    unpacked_weights = {}

    # update unpacked weights dictionary with values from weights dictionary
    def unpack_weights(d):
        if type(d) == type({}):
            for k in d:
                unpacked_weights.update({k: d[k][0]})
                unpack_weights(d[k])
        if type(d) == type([]) and len(d) > 1:
            for k in d[1]:
                unpacked_weights.update({k: d[1][k][0]})
            unpack_weights(d[1])

    unpack_weights(weights)

    for key in unpacked_weights:
        if key in field_name_xwalk.keys():
            unpacked_weights[field_name_xwalk[key]] = unpacked_weights[key]
            del unpacked_weights[key]

    return unpacked_weights


# get single dimensional value function (SDVF) for fields where higher values are important
# i.e. higher rating
def high_values_important(min_val, max_val, x):
    if x == min_val:
        sdvf = 0
    else:
        sdvf = (x - min_val) / (max_val - min_val)
    return sdvf


# get single dimensional value function (SDVF) for fields where lower values are important
# i.e. lower price
def low_values_important(min_val, max_val, x):
    if x == max_val:
        sdvf = 0
    else:
        sdvf = (x - max_val) / (min_val - max_val)
    return sdvf


# Apply high value SDVF to a whole field
def evaluate_high_values(df, series):
    min_val = df[series].min()
    max_val = df[series].max()
    df[series] = df[series].apply(lambda x: high_values_important(min_val, max_val, x))
    return df


# Apply low value SDVF to a whole field
def evaluate_low_values(df, series):
    min_val = df[series].min()
    max_val = df[series].max()
    df[series] = df[series].apply(lambda x: low_values_important(min_val, max_val, x))
    return df


# Create the ranked listings dataset based on the weights from the user ratings
def create_ranked_data(df, Environmental_Features):
    weights = return_weights(structure, Environmental_Features)
    unpacked_weights = return_unpacked_weights(weights)

    # limited sample listings data to only the fields we have
    required_headers = [x for x in unpacked_weights if x in list(df.columns)]
    df_final = copy.deepcopy(df)
    filtered_headers = ["Listing_ID"] + required_headers
    df = df.loc[:, filtered_headers]

    # list which model features need to be ranked by high or low values
    high_vals = ["size_in_sqft", "RATING", "Mean_Rating_restaurants",
                 "Mean_Rating_bars"]  # fields where high vals are important
    low_vals = [x for x in required_headers if x not in high_vals]  # fields where low vals are important

    # assign a numeric value based on how high or low the SDVF is
    for col in high_vals:
        df = evaluate_high_values(df, col)
    for col in low_vals:
        df = evaluate_low_values(df, col)

    # Create a cumulative sum product column called User Value
    df['user_value'] = (df[required_headers] * [unpacked_weights[x] for x in required_headers]).sum(axis=1)
    df = evaluate_high_values(df, 'user_value')

    # Drop all columns except the listing ID and user value, rejoin with original listing data
    df = df.drop(columns=required_headers)
    df = df.set_index("Listing_ID")
    df_final = df_final.join(df, on="Listing_ID", rsuffix="_X")
    df_final = df_final.sort_values('user_value', ascending=False)
    return df_final

# ranked = create_ranked_data(listings, Environmental_Features)